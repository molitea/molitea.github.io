<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>函数调用的栈变化和布局</title>
    <url>/2021/02/24/function_call_stack/</url>
    <content><![CDATA[<p>函数调用的栈变化和布局情况：</p>
<ol>
<li>栈生长方向是高地址到低地址生长；</li>
<li>进入函数中时，执行<code>push ebp; mov ebp, esp</code>初始化ebp寄存器为栈底；</li>
<li><code>sub esp, xxx</code>为函数内的局部变量分配空间，并使栈顶寄存器esp向低地址移动（生长）；</li>
<li>从上到下，从低地址到高地址，整个函数调用过程中的栈布局是：局部变量、原始调用者的ebp，函数返回地址，函数参数；</li>
<li>使用ebp，esp寄存器访问参数的情况：ebp+xx，esp+xx；</li>
<li>使用ebp，esp寄存器访问局部变量的情况：ebp-xx，esp+xx，esp-xx；</li>
<li>栈溢出时，从上到下，从低地址向高地址溢出，最终覆盖了位于下方高地址的函数返回地址（ret-address）。</li>
</ol>
<p><img src="https://gitee.com/molitea/blog-images/raw/master/img/20201211103735.png"></p>
]]></content>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常用命令</title>
    <url>/2021/02/24/git-command-list/</url>
    <content><![CDATA[<p>常用git命令归纳：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>git init</td>
<td>初始化仓库</td>
</tr>
<tr>
<td>git add <file></td>
<td>添加指定文件到暂存区</td>
</tr>
<tr>
<td>git add .</td>
<td>添加所有文件到暂存区</td>
</tr>
<tr>
<td>git commit -m “xxxx”</td>
<td>提交到仓库，git commit只会提交在暂存区中的内容</td>
</tr>
<tr>
<td>git status</td>
<td>查看状态</td>
</tr>
<tr>
<td>git clone <url></td>
<td>克隆仓库的当前分支</td>
</tr>
<tr>
<td>git clone -b <branch-name> <url></td>
<td>克隆仓库的指定分支</td>
</tr>
<tr>
<td>git diff</td>
<td>查看修改的内容</td>
</tr>
<tr>
<td>git log</td>
<td>查看历史提交</td>
</tr>
<tr>
<td>git log –pretty=oneline</td>
<td>查看历史提交，并且输出信息在一行显示</td>
</tr>
<tr>
<td>git reset –hard HEAD^</td>
<td>回退到上一个版本，HEAD指向的版本就是当前版本，HEAD^ 当前版本的上一个版本 ，HEAD^^ 上上个版本 ，HEAD~100 当前往上100个版本</td>
</tr>
<tr>
<td>git reset –hard <commit_id></td>
<td>回退到某个版本</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看历史提交记录</td>
</tr>
<tr>
<td>git checkout – <file></td>
<td>恢复工作区文件的原始内容</td>
</tr>
<tr>
<td>git checkout .</td>
<td>恢复工作区的所有文件</td>
</tr>
<tr>
<td>git reset HEAD file</td>
<td>撤销暂存区的内容</td>
</tr>
<tr>
<td>git rm file     git commit -m “xxxx”</td>
<td>删除文件</td>
</tr>
<tr>
<td>git remote add origin git@server-name:path/repo-name.git</td>
<td>关联远程库</td>
</tr>
<tr>
<td>git push -u origin master</td>
<td>关联后，第一次推送master分支的所有内容</td>
</tr>
<tr>
<td>git push origin master</td>
<td>此后，每次推送到master分支</td>
</tr>
<tr>
<td>git checkout -b xxxx  、git switch -c xxxx（新版本）</td>
<td>创建并切换到xxxx分支，git checkout -b xxxx 相当于两条命令：git branch xxxx、 git checkout xxxx（新版本git switch xxxx）</td>
</tr>
<tr>
<td>git branch</td>
<td>查看当前分支</td>
</tr>
<tr>
<td>git merge xxxx</td>
<td>合并指定分支到当前分支(Fast forward  模式) ，例如：合并xxxx分支到当前分支</td>
</tr>
<tr>
<td>git branch -d xxxx</td>
<td>删除本地分支</td>
</tr>
<tr>
<td>git branch -D xxxx</td>
<td>强制删除本地分支</td>
</tr>
<tr>
<td>git push origin –delete xxxx</td>
<td>删除远程分支</td>
</tr>
<tr>
<td>git merge –no-ff -m “msg” xxxx</td>
<td>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并</td>
</tr>
<tr>
<td>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</td>
<td>从远程获取代码并合并本地的版本</td>
</tr>
<tr>
<td>git pull origin master:brantest</td>
<td>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并</td>
</tr>
<tr>
<td>git pull origin master</td>
<td>如果远程分支是与当前分支合并，则冒号后面的部分可以省略</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>札记or备忘录</title>
    <url>/2021/02/24/misc/</url>
    <content><![CDATA[<h1 id="札记or备忘录"><a href="#札记or备忘录" class="headerlink" title="札记or备忘录"></a>札记or备忘录</h1><h2 id="Python数据可视化库"><a href="#Python数据可视化库" class="headerlink" title="Python数据可视化库"></a>Python数据可视化库</h2><p>pyecharts——<a href="https://github.com/ecomfe/echarts">Echarts</a> 是一个由百度开源的数据可视化，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。而 Python 是一门富有表达力的语言，很适合用于数据处理。当数据分析遇上数据可视化时，<a href="https://github.com/pyecharts/pyecharts">pyecharts</a> 诞生了。</p>
<p>igraph——igraph是网络分析工具的集合，着重于效率，可移植性和易用性。igraph开源、免费，可以使用R、Python、Mathematica和C/C++进行编程。（构建图结构）</p>
<p>networkx——networkx在2002年5月产生，是一个用Python语言开发的图论与复杂网络建模工具，内置了常用的图与复杂网络分析算法，可以方便的进行复杂网络数据分析、仿真建模等工作。networkx支持创建简单无向图、有向图和多重图；内置许多标准的图论算法，节点可为任意数据；支持任意的边值维度，功能丰富，简单易用。</p>
<h2 id="网络流量分析"><a href="#网络流量分析" class="headerlink" title="网络流量分析"></a>网络流量分析</h2><p>Zeek（以前称为Bro）——一款被动的开源网络流量分析器，它的主要用作一种安全监视器，可以对链接上的所有流量进行深入检查，并且生成大量的日志文件，以便于查找可疑活动的迹象。</p>
<p>Moloch——Moloch是一个开源，大规模，完整的数据包捕获，索引和数据库系统。</p>
<p><a href="https://blog.51cto.com/liufei888/2455000">《14个网络管理员必备的最佳网络流量分析工具》</a></p>
<p><a href="https://www.brimsecurity.com/">BRIM</a></p>
<h2 id="网络侦查框架工具"><a href="#网络侦查框架工具" class="headerlink" title="网络侦查框架工具"></a>网络侦查框架工具</h2><p>ivre、reNgine</p>
<p>FinalRecon、Sandmap</p>
<h2 id="取证工具"><a href="#取证工具" class="headerlink" title="取证工具"></a><a href="http://www.yidianzixun.com/article/0JGUTuyf">取证工具</a></h2><h3 id="内存取证"><a href="#内存取证" class="headerlink" title="内存取证"></a>内存取证</h3><p>Windows：dumpit\RAMCapturer\Magnet RAM Capture\WinEn\Winpmem\EnCase Imager\FTK Imager\取证大师\取证神探</p>
<p>Linux：</p>
<p>dd（适合Linux早期版本）</p>
<p><a href="https://github.com/504ensicslabs/lime">LiME</a>\linpmem\Draugr\<a href="https://code.google.com/archive/p/volatilitux/">Volatilitux</a>\<a href="https://lcamtuf.coredump.cx/">Memfetch</a>\<a href="http://manpages.ubuntu.com/manpages/bionic/en/man1/memdump.1.html">Memdump</a></p>
<p><a href="https://www.jamesbower.com/linux-memory-analysis/">《Linux Memory Analysis》</a></p>
<p>**<a href="https://github.com/microsoft/avml">AVML</a>**——<a href="https://stuxnet999.github.io/dfir/2020/09/20/Linux-Memory-Forensics.html">《<strong>Intro to Linux memory forensics</strong>》</a></p>
<p>linux内存镜像分析的时候需要Profile，所以也许取单个进程的内存是一个好的选择。（使用gdb dump地址空间数据）</p>
<h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><p><a href="https://soshace.com/comparative-analysis-of-free-tools-for-physical-memory-dumps-parsing/">Comparative Analysis of Free Tools for Physical Memory Dumps Parsing</a></p>
]]></content>
  </entry>
  <entry>
    <title>Python 线程池</title>
    <url>/2021/02/24/python_thread_pool/</url>
    <content><![CDATA[<p><strong>什么是线程池</strong></p>
<p>Web服务器、数据库服务器、文件服务器、邮件服务器等许多服务器应用都面向处理来自某些远程来源的<strong>大量短小的任务</strong>。构建服务器应用程序的一个过于简单的模型是：每当一个请求到达就创建一个新的服务对象，然后在新的服务对象中为请求服务。但当有大量请求并发访问时，服务器不断的创建和销毁对象的开销很大。所以提高服务器效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这样就引入了“池”的概念，“池”的概念使得人们可以定制一定量的资源，然后对这些资源进行复用，而不是频繁的创建和销毁。</p>
<p>线程池是预先创建线程的一种技术。线程池在还没有任务到来之前，创建一定数量的线程，放入空闲队列中。这些线程都是处于睡眠状态，即均为启动，不消耗CPU，而只是占用较小的内存空间。当请求到来之后，缓冲池给这次请求分配一个空闲线程，把请求传入此线程中运行，进行处理。当预先创建的线程都处于运行状态，即预制线程不够，线程池可以自由创建一定数量的新线程，用于处理更多的请求。当系统比较闲的时候，也可以通过移除一部分一直处于停用状态的线程。</p>
<p><strong>线程池的注意事项</strong></p>
<p>虽然线程池是构建多线程应用程序的强大机制，但使用它并不是没有风险的。在使用线程池时需注意线程池大小与性能的关系，注意并发风险、死锁、资源不足和线程泄漏等问题。</p>
<p><strong>1）线程池大小</strong></p>
<p>多线程应用并非线程越多越好，需要根据系统运行的软硬件环境以及应用本身的特点决定线程池的大小。一般来说，如果代码结构合理的话，线程数目与CPU 数量相适合即可。如果线程运行时可能出现阻塞现象，可相应增加池的大小；如有必要可采用自适应算法来动态调整线程池的大小，以提高CPU 的有效利用率和系统的整体性能。</p>
<p><strong>2）并发错误</strong></p>
<p>多线程应用要特别注意并发错误，要从逻辑上保证程序的正确性，注意避免死锁现象的发生。</p>
<p><strong>3）线程泄漏</strong></p>
<p>这是线程池应用中一个严重的问题，当任务执行完毕而线程没能返回池中就会发生线程泄漏现象。</p>
<p><strong>线程池的设计</strong></p>
<p>一个典型的线程池，应该包括如下几个部分：</p>
<p>1、线程池管理器（ThreadPool），用于启动、停用，管理线程池</p>
<p>2、工作线程（WorkThread），线程池中的线程</p>
<p>3、请求接口（WorkRequest），创建请求对象，以供工作线程调度任务的执行</p>
<p>4、请求队列（RequestQueue），用于存放和提取请求</p>
<p>5、结果队列（ResultQueue），用于存储请求执行后返回的结果</p>
<p>线程池管理器，通过添加请求的方法（putRequest）向请求队列（RequestQueue）添加请求，这些请求事先需要实现请求接口，即传递工作函数、参数、结果处理函数、以及异常处理函数。</p>
<p>接着，初始化一定数量的工作线程，这些线程通过轮询的方式不断查看请求队列（RequestQueue），只要有请求存在，则会提取出请求，进行执行。</p>
<p>然后，线程池管理器调用方法（poll）查看结果队列（resultQueue）是否有值，如果有值，则取出，调用结果处理函数执行。</p>
<p>通过以上讲述，不难发现，这个系统的核心资源在于请求队列和结果队列，工作线程通过轮询requestQueue获得任务，主线程通过查看结果队列，获得执行结果。</p>
<p><strong>如何实现线程池</strong>？</p>
<p>这里，我分别介绍两种实现方式：</p>
<p><strong>第一种：threadpool（老配方）</strong></p>
<p>使用threadpool模块，这是个python的第三方模块，支持python2和python3，具体使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threadpool <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自己在ThreadPool类中添加的方法</span></span><br><span class="line"><span class="comment"># def workersize(self):</span></span><br><span class="line"><span class="comment">#         return len(self.workers)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def stop(self):</span></span><br><span class="line"><span class="comment">#     &#x27;&#x27;&#x27;join 所有的thread,确保所有的线程都执行完毕&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     self.dismissWorkers(self.workersize(), True)</span></span><br><span class="line"><span class="comment">#     self.joinAllDismissedWorkers()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_work</span>(<span class="params">data</span>):</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    res = <span class="built_in">str</span>(datetime.datetime.now()) + <span class="string">&quot;&quot;</span> + <span class="built_in">str</span>(data)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_result</span>(<span class="params">request, result</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;---Result from request %s : %r&quot;</span> % (request.requestID, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main = ThreadPool(<span class="number">3</span>)</span><br><span class="line">     </span><br><span class="line">    reqs = makeRequests(do_work, [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)], print_result)</span><br><span class="line">    <span class="keyword">for</span> i, req <span class="keyword">in</span> <span class="built_in">enumerate</span>(reqs):</span><br><span class="line">        main.putRequest(req)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;(%d): work request #%s added.&quot;</span> % (i, req.requestID)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(20):</span></span><br><span class="line">    <span class="comment">#     req = WorkRequest(do_work, args=[i], callback=print_result)</span></span><br><span class="line">    <span class="comment">#     # req = WorkRequest(do_work, args=(i,), callback=print_result)        # ok too</span></span><br><span class="line">    <span class="comment">#     main.putRequest(req)</span></span><br><span class="line">    <span class="comment">#     print &quot;(%d): work request #%s added.&quot; % (i, req.requestID)</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span> * <span class="number">20</span>, main.workersize(), <span class="string">&#x27;-&#x27;</span> * <span class="number">20</span></span><br><span class="line">     </span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            main.poll()</span><br><span class="line">            <span class="keyword">if</span>(counter == <span class="number">5</span>):</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;Add 3 more workers threads&quot;</span></span><br><span class="line">                main.createWorkers(<span class="number">3</span>)</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span> * <span class="number">20</span>, main.workersize(), <span class="string">&#x27;-&#x27;</span> * <span class="number">20</span></span><br><span class="line">            <span class="keyword">if</span>(counter == <span class="number">10</span>):</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&quot;dismiss 2 workers threads&quot;</span></span><br><span class="line">                main.dismissWorkers(<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;-&#x27;</span> * <span class="number">20</span>, main.workersize(), <span class="string">&#x27;-&#x27;</span> * <span class="number">20</span></span><br><span class="line">            counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> NoResultsPending:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;no pending results&quot;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">     </span><br><span class="line">    main.stop()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Stop &amp; End.&quot;</span></span><br></pre></td></tr></table></figure>

<p>threadpool是一个比较老的模块了，现在虽然还有一些人在用，但已经不再是主流了，关于python多线程，现在已经开始步入未来（futures模块）了。</p>
<p><strong>第二种：futures（新配方）</strong></p>
<p>使用concurrent.futures模块，这个模块是python3中自带的模块，在python2.7以上的版本需要安装（pip install futures）才能使用。具体使用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name, seconds</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;%s sleep %s seconds start...&#x27;</span> % (name, seconds)</span><br><span class="line">    time.sleep(seconds)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;%s sleep %s seconds done&#x27;</span> % (name, seconds)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s task done&#x27;</span> % name</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> t:</span><br><span class="line">    task1 = t.submit(task, <span class="string">&#x27;xxxx&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    task2 = t.submit(task, <span class="string">&#x27;zzzz&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">    task3 = t.submit(task, <span class="string">&#x27;yyyy&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">    task4 = t.submit(task, <span class="string">&#x27;mmmm&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">    print(task1.done())</span><br><span class="line">    print(task2.done())</span><br><span class="line">    print(task3.done())</span><br><span class="line">    print(task4.done())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(task1.done())</span><br><span class="line">    print(task2.done())</span><br><span class="line">    print(task3.done())</span><br><span class="line">    print(task4.done())</span><br><span class="line"></span><br><span class="line">    print(task1.result())</span><br><span class="line">    print(task2.result())</span><br><span class="line">    print(task3.result())</span><br><span class="line">    print(task4.result())</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 with 语句 ，通过 ThreadPoolExecutor 构造实例，同时传入 max_workers 参数来设置线程池中最多能同时运行的线程数目。</li>
<li>使用 submit 函数来提交线程需要执行的任务到线程池中，并返回该任务的句柄（类似于文件、画图），注意 submit() 不是阻塞的，而是立即返回。</li>
<li>通过使用 done() 方法判断该任务是否结束。上面的例子可以看出，提交任务后立即判断任务状态，显示四个任务都未完成。在延时2.5后，task1 和 task2 执行完毕，task3 仍在执行中。</li>
<li>使用 result() 方法可以获取任务的返回值 <strong>【注意result 是阻塞的会阻塞主线程】</strong></li>
</ul>
<p>concurrent.futures中的常用方法：</p>
<p><strong>wait</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wait(fs, timeout=<span class="literal">None</span>, return_when=ALL_COMPLETED)</span><br></pre></td></tr></table></figure>

<p>fs: 表示需要执行的序列；<br>timeout: 等待的最大时间，如果超过这个时间即使线程未执行完成也将返回；<br>return_when：表示wait返回结果的条件，默认为 ALL_COMPLETED 全部执行完成再返回；可指定FIRST_COMPLETED 当第一个执行完就退出阻塞。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,wait,FIRST_COMPLETED, ALL_COMPLETED</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">task_args_list = [(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">1</span>),(<span class="string">&#x27;lishi&#x27;</span>,<span class="number">2</span>), (<span class="string">&#x27;wangwu&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line">task_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name, seconds</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;% sleep %s seconds start...&#x27;</span> % (name, seconds))</span><br><span class="line">    time.sleep(seconds)</span><br><span class="line">    print(<span class="string">&#x27;% sleep %s seconds done&#x27;</span> % (name, seconds))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s task done&#x27;</span> % name</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> t:</span><br><span class="line">    [task_list.append(t.submit(task, *arg)) <span class="keyword">for</span>  arg <span class="keyword">in</span> task_args_list]</span><br><span class="line">    wait(task_list, return_when=FIRST_COMPLETED)</span><br><span class="line">    print(<span class="string">&#x27;all_task_submit_complete! and First task complete!&#x27;</span>)</span><br><span class="line">    print(wait(task_list,timeout=<span class="number">1.5</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">zhangsanleep <span class="number">1</span> seconds start...</span><br><span class="line">lishileep <span class="number">2</span> seconds start...</span><br><span class="line">wangwuleep <span class="number">3</span> seconds start...</span><br><span class="line">zhangsanleep <span class="number">1</span> seconds done</span><br><span class="line">all_task_submit_complete! <span class="keyword">and</span> First task complete!</span><br><span class="line">lishileep <span class="number">2</span> seconds done</span><br><span class="line">DoneAndNotDoneFutures(done=<span class="built_in">set</span>([&lt;Future at <span class="number">0x33b8708</span> state=finished returned <span class="built_in">str</span>&gt;, &lt;Future at <span class="number">0x33b8d08</span> state=finished returned <span class="built_in">str</span>&gt;]), not_done=<span class="built_in">set</span>([&lt;Future at <span class="number">0x33be288</span> state=running&gt;]))</span><br><span class="line">wangwuleep <span class="number">3</span> seconds done</span><br></pre></td></tr></table></figure>

<p><strong>as_completed</strong></p>
<p>上面虽提供了done()方法判断任务是否结束的方法，但是不能在主线程中一直判断。最好的方法是当某个任务结束了，就给主线程返回结果，而不是一直判断每个任务是否结束。</p>
<p>concurrent.futures 中 的 as_completed() 就是这样一个方法，当子线程中的任务执行完后，直接用 result() 获取返回结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">task_args_list = [(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">1</span>),(<span class="string">&#x27;lishi&#x27;</span>,<span class="number">3</span>), (<span class="string">&#x27;wangwu&#x27;</span>, <span class="number">2</span>)]</span><br><span class="line">task_list = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name, seconds</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;%s sleep %s seconds start...&#x27;</span> % (name, seconds))</span><br><span class="line">    time.sleep(seconds)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s sleep %s seconds done&#x27;</span> % (name, seconds)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> t:</span><br><span class="line">    [task_list.append(t.submit(task, *arg)) <span class="keyword">for</span> arg <span class="keyword">in</span> task_args_list]</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(task_list):</span><br><span class="line">        print(future.result())</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;All Task Done!!!!!!!!!&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line">zhangsan sleep <span class="number">1</span> seconds start...</span><br><span class="line">lishi sleep <span class="number">3</span> seconds start...</span><br><span class="line">wangwu sleep <span class="number">2</span> seconds start...</span><br><span class="line">zhangsan sleep <span class="number">1</span> seconds done</span><br><span class="line">wangwu sleep <span class="number">2</span> seconds done</span><br><span class="line">lishi sleep <span class="number">3</span> seconds done</span><br><span class="line">All Task Done!!!!!!!!!</span><br></pre></td></tr></table></figure>

<p><strong>map</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(fn, *iterables, timeout=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>fn： 第一个参数 fn 是需要线程执行的函数；<br>iterables：第二个参数接受一个可迭代对象；<br>timeout： 第三个参数 timeout 跟 wait() 的 timeout 一样，但由于 map 是返回线程执行的结果，如果 timeout小于线程执行时间会抛异常 TimeoutError。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spider</span>(<span class="params">page</span>):</span></span><br><span class="line">    time.sleep(page)</span><br><span class="line">    <span class="keyword">return</span> page</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> executor.<span class="built_in">map</span>(spider, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]):</span><br><span class="line">    print(<span class="string">&quot;task&#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, result))</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  运行结果</span></span><br><span class="line">task1:<span class="number">2</span></span><br><span class="line">task2:<span class="number">3</span></span><br><span class="line">task3:<span class="number">1</span></span><br><span class="line">task4:<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>使用 map 方法，无需提前使用 submit 方法，map 方法与 python 高阶函数 map 的含义相同，都是将序列中的每个元素都执行同一个函数。上面的代码对列表中的每个元素都执行 spider() 函数，并分配各线程池。</p>
<p>可以看到map执行结果与上面的 as_completed() 方法的结果不同，输出顺序和列表的顺序相同，就算 1s 的任务先执行完成，也会先打印前面提交的任务返回的结果。</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>threadpool</tag>
        <tag>futures</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器固件模拟</title>
    <url>/2021/02/24/qemu-emulation-iot-device/</url>
    <content><![CDATA[<h2 id="固件提取——binwalk"><a href="#固件提取——binwalk" class="headerlink" title="固件提取——binwalk"></a>固件提取——binwalk</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install build-essential autoconf git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/devttys0/binwalk.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binwalk</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> python2.7安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo python setup.py install</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动安装依赖库文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./deps.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提取固件 -M递归提取</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> binwalk -Me XX.bin</span></span><br></pre></td></tr></table></figure>

<h2 id="模拟执行——qemu"><a href="#模拟执行——qemu" class="headerlink" title="模拟执行——qemu"></a>模拟执行——qemu</h2><h3 id="qemu安装"><a href="#qemu安装" class="headerlink" title="qemu安装"></a>qemu安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install qemu </span><br><span class="line"><span class="meta">#</span><span class="bash">user mode,包含qemu-mips-static，qemu-mipsel-static,qemu-arm-static等</span></span><br><span class="line">sudo apt-get install qemu-user-static</span><br><span class="line"><span class="meta">#</span><span class="bash">system mode，包含qemu-system-mips，qemu-system-mipsel,qemu-system-arm等</span></span><br><span class="line">sudo apt-get install qemu-system</span><br></pre></td></tr></table></figure>

<h3 id="qemu有两种运行模式"><a href="#qemu有两种运行模式" class="headerlink" title="qemu有两种运行模式"></a>qemu有两种运行模式</h3><p>user mode : qemu-mips(mipsel/arm)-static。用户只需要将各种不同平台的处理编译得到的Linux程序放在QEMU虚拟中运行即可，其他的事情全部由QEMU虚拟机来完成，不需要用户自定义内核和虚拟磁盘等文件；</p>
<p>system mode:qemu-system-mips(mipsel) : 用户可以为QEMU虚拟机指定运行的内核或者虚拟硬盘等文件，简单来说系统模式下QEMU虚拟机是可根据用户的要求配置的。</p>
<h4 id="user-mode"><a href="#user-mode" class="headerlink" title="user mode"></a>user mode</h4><p>用户模式下需要切换”/“目录，使用的是chroot命令，将根目录切换到binwalk提取出的文件系统目录下，例如squashfs-root，cpio-root。</p>
<p>在需要指定新的动态库实现一些函数的劫持时，用-E LD_PRELOAD=”XX.so”</p>
<p>开启调试模式时，使用-g 1234</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将qemu-mips-static拷贝到当前目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp $(<span class="built_in">which</span> qemu-mips-static) .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chroot . ./qemu-mips-static -E LD_PRELOAD=<span class="string">&quot;XX.so&quot;</span> -g 1234 bin/boa</span></span><br></pre></td></tr></table></figure>

<h4 id="system-mode"><a href="#system-mode" class="headerlink" title="system mode"></a>system mode</h4><p>用这个模式稍微麻烦一点点，但是能获取到的信息也比较多，比如能够查看qemu内部进程的内存分布，设备之类的情况。</p>
<p>1.配置网卡</p>
<p>参考《qemu网络配置》</p>
<p>2.启动qemu</p>
<p>两个镜像下载：<a href="https://people.debian.org/~aurel32/qemu/mips/">debian</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta \</span></span><br><span class="line"><span class="bash">-hda debian_squeeze_mips_standard.qcow2 \</span></span><br><span class="line"><span class="bash">-append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> \</span></span><br><span class="line"><span class="bash">-net nic -net tap -nographic -s</span></span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-M 指定开发板 你能够使用-M ?參数来获取该qemu版本号支持的全部单板 （qemu-system-mips -M help 可查看支持列表）</span><br><span class="line">-kernel 内核镜像路径</span><br><span class="line">-hda/-hdb IDE硬盘镜像</span><br><span class="line">-append 内核启动参数 内核命令行</span><br><span class="line">-s 等同于-g 1234</span><br></pre></td></tr></table></figure>

<p>3.开启qemu之后，将binwalk提取出的文件系统拷贝到虚拟机中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scp -r ./cpio-root  root@192.168.84.129:/root/</span></span><br></pre></td></tr></table></figure>

<p>4.接下来就可以在远端mips虚拟机上运行程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> LD_PRELOAD=<span class="string">&#x27;XX.so&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chroot . bin/busybox</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xz.aliyun.com/t/1508">《一步一步PWN路由器之环境搭建》</a></p>
<p><a href="https://xz.aliyun.com/t/5697">《路由器固件模拟环境搭建》</a></p>
]]></content>
      <tags>
        <tag>iot</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU网络配置</title>
    <url>/2021/02/24/qemu-network-config/</url>
    <content><![CDATA[<p><a href="https://wzt.ac.cn/2019/09/10/QEMU-networking/">《QEMU 网络配置》</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install qemu </span><br><span class="line">apt-get install qemu-user-static</span><br><span class="line">apt-get install qemu-system</span><br><span class="line">apt-get install uml-utilities</span><br><span class="line">apt-get install bridge-utils</span><br><span class="line"></span><br><span class="line">ifconfig &lt;你的网卡名称&gt; down</span><br><span class="line">brctl addbr br0     # add bridge br0</span><br><span class="line">brctl addif br0 &lt;你的网卡名称&gt;     # add interface to br0</span><br><span class="line">brctl stp br0 off   # 如果只有一个网桥，则关闭生成树协议</span><br><span class="line">brctl setfd br0 1   # 设置br0的转发延迟</span><br><span class="line">brctl sethello br0 1    # 设置br0的hello时间</span><br><span class="line">ifconfig br0 0.0.0.0 promisc up # 启用br0</span><br><span class="line">ifconfig &lt;你的网卡名称&gt; 0.0.0.0 promisc up</span><br><span class="line">dhclient br0        # 从dhcp服务器获取br0的IP地址</span><br><span class="line">brctl show br0</span><br><span class="line"></span><br><span class="line">tunctl -t tap0 -u root	# 创建一个tap0的接口，只允许root用户访问</span><br><span class="line">brctl addif br0 tap0 # 在虚拟网桥中添加一个tap0接口</span><br><span class="line">ifconfig tap0 0.0.0.0 promisc up # 启用tap0接口</span><br><span class="line">brctl showstp br0   # 显示 br0 的各个接口</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启用qemu</span></span><br><span class="line">sudo qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">特别说明一下参数含义：-net nic 表示希望 QEMU 在虚拟机中创建一张虚拟网卡，-net tap 表示连接类型为 TAP，并且指定了网卡接口名称(就是刚才创建的 tap0，相当于把虚拟机接入网桥)。script 和 downscript 两个选项的作用是告诉 QEMU 在启动系统的时候是否调用脚本自动配置网络环境，如果这两个选项为空，那么 QEMU 启动和退出时会自动选择第一个不存在的 tap 接口(通常是 tap0)为参数，调用脚本 /etc/qemu-ifup 和 /etc/qemu-ifdown。由于我们已经配置完毕，所以这两个参数设置为 no 即可。</span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11常用特性</title>
    <url>/2021/02/24/cpp11-new-features/</url>
    <content><![CDATA[<h2 id="关键字及新语法"><a href="#关键字及新语法" class="headerlink" title="关键字及新语法"></a>关键字及新语法</h2><h3 id="auto关键字及用法"><a href="#auto关键字及用法" class="headerlink" title="auto关键字及用法"></a>auto关键字及用法</h3><p><strong>A、auto关键字能做什么？</strong></p>
<p>auto并没有让C++成为弱类型语言，也没有弱化变量什么，只是使用auto的时候，编译器根据上下文情况，确定auto变量的真正类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">AddTest</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> index = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> ret = AddTest(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;index:&quot;</span> &lt;&lt; index &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str:&quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;res:&quot;</span> &lt;&lt; ret &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>B、auto不能做什么？</strong></p>
<p>auto作为函数返回值时，只能用于定义函数，不能用于声明函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">TestWork</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如下函数中，在引用头文件的调用TestWork函数是，编译无法通过。</p>
<p>但如果把实现写在头文件中，可以编译通过，因为编译器可以根据函数实现的返回值确定auto的真实类型。如果读者用过inline类成员函数，这个应该很容易明白，此特性与inline类成员函数类似。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">TestWork</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="nullptr关键字及用法"><a href="#nullptr关键字及用法" class="headerlink" title="nullptr关键字及用法"></a>nullptr关键字及用法</h3><p>为什么需要nullptr? NULL有什么毛病？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestWork</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;TestWork 1&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestWork</span><span class="params">(<span class="keyword">int</span> * index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;TestWork 2&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.TestWork(<span class="literal">NULL</span>);</span><br><span class="line">    test.TestWork(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TestWork 1</span><br><span class="line">TestWork 2</span><br></pre></td></tr></table></figure>

<p>NULL在c++里表示空指针，看到问题了吧，我们调用test.TestWork(NULL)，其实期望是调用的是void TestWork(int * index)，但结果调用了void TestWork(int index)。但使用nullptr的时候，我们能调用到正确的函数。</p>
<h3 id="for循环语法"><a href="#for循环语法" class="headerlink" title="for循环语法"></a>for循环语法</h3><p>OK，直接以简单示例看看用法吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;numbers:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> number : numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上用法不仅仅局限于数据，STL容器都同样适用。</p>
<h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><p>总结C++11新增的一些容器，以及对其实现做一些简单的解释。</p>
<h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h3><p>std::array跟数组并没有太大区别，std::array相对于数组，增加了迭代器等函数（接口定义可参考C++官方文档）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; arrayDemo = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arrayDemo:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itor : arrayDemo)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; itor &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> arrayDemoSize = <span class="keyword">sizeof</span>(arrayDemo);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arrayDemo size:&quot;</span> &lt;&lt; arrayDemoSize &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a>std::forward_list</h3><p>std::forward_list为C++新增的线性表，与list区别在于它是单向链表。我们在学习数据结构的时候都知道，链表在对数据进行插入和删除是比顺序存储的线性表有优势，因此在插入和删除操作频繁的应用场景中，使用list和forward_list比使用array、vector和deque效率要高很多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;numbers:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> number : numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    numbers.remove(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;numbers after remove:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> number : numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-unordered-map"><a href="#std-unordered-map" class="headerlink" title="std::unordered_map"></a>std::unordered_map</h3><p>std::unordered_map与std::map用法基本差不多，但STL在内部实现上有很大不同，std::map使用的数据结构为二叉树，而std::unordered_map内部是哈希表的实现方式，哈希map理论上查找效率为O(1)。但在存储效率上，哈希map需要增加哈希表的内存开销。</p>
<p>下面代码为C++官网实例源码实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mymap =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; <span class="string">&quot;house&quot;</span>,<span class="string">&quot;maison&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;apple&quot;</span>,<span class="string">&quot;pomme&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;tree&quot;</span>,<span class="string">&quot;arbre&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;book&quot;</span>,<span class="string">&quot;livre&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;door&quot;</span>,<span class="string">&quot;porte&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;grapefruit&quot;</span>,<span class="string">&quot;pamplemousse&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> n = mymap.bucket_count();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mymap has &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; buckets.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i&lt;n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bucket #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; contains: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mymap.begin(i); it != mymap.end(i); ++it)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-unordered-set"><a href="#std-unordered-set" class="headerlink" title="std::unordered_set"></a>std::unordered_set</h3><p>std::unordered_set的数据存储结构也是哈希表的方式结构，除此之外，std::unordered_set在插入时不会自动排序，这都是std::set表现不同的地方。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; unorder_set;</span><br><span class="line">    unorder_set.insert(<span class="number">7</span>);</span><br><span class="line">    unorder_set.insert(<span class="number">5</span>);</span><br><span class="line">    unorder_set.insert(<span class="number">3</span>);</span><br><span class="line">    unorder_set.insert(<span class="number">4</span>);</span><br><span class="line">    unorder_set.insert(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unorder_set:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itor : unorder_set)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; itor &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="built_in">set</span>.insert(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">set</span>.insert(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">set</span>.insert(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">set</span>.insert(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">set</span>.insert(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;set:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itor : <span class="built_in">set</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; itor &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>在C++11以前，C++的多线程编程均需依赖系统或第三方接口实现，一定程度上影响了代码的移植性。C++11中，引入了boost库中的多线程部分内容，形成C++标准，形成标准后的boost多线程编程部分接口基本没有变化，这样方便了以前使用boost接口开发的使用者切换使用C++标准接口，把容易把boost接口升级为C++接口。</p>
<h3 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h3><p>std::thread为C++11的线程类，使用方法和boost接口一样，非常方便，同时，C++11的std::thread解决了boost::thread中构成参数限制的问题，我想着都是得益于C++11的可变参数的设计风格。</p>
<p>我们通过如下代码熟悉下std::thread使用风格。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadfun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;threadfun1 - 1\r\n&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;threadfun1 - 2&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadfun2</span><span class="params">(<span class="keyword">int</span> iParam, <span class="built_in">std</span>::<span class="built_in">string</span> sParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;threadfun2 - 1&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;threadfun2 - 2&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(threadfun1)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(threadfun2, <span class="number">10</span>, <span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;join&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    t2.detach();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;detach&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1.join()会等待t1线程退出后才继续往下执行，t2.detach()并不会并不会把，detach字符输出后，主函数退出，threadfun2还未执行完成，但是在主线程退出后，t2的线程也被已经被强退出。</p>
<h3 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h3><p>std::atomic为C++11分装的原子数据类型。</p>
<p>什么是原子数据类型？</p>
<p>从功能上看，简单地说，原子数据类型不会发生数据竞争，能直接用在多线程中而不必我们用户对其进行添加互斥资源锁的类型。从实现上，大家可以理解为这些原子类型内部自己加了锁。</p>
<p>我们下面通过一个测试例子说明原子类型std::atomic_int的特点。</p>
<p>下面例子中，我们使用10个线程，把std::atomic_int类型的变量iCount从100减到1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">atomic_bool</span> bIsReady = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">atomic_int</span> iCount = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadfun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bIsReady) &#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (iCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;iCount:%d\r\n&quot;</span>, iCount--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">atomic_bool</span> b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::thread&gt; lstThread;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        lstThread.push_back(<span class="built_in">std</span>::thread(threadfun1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : lstThread)</span><br><span class="line">    &#123;</span><br><span class="line">        th.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-condition-variable"><a href="#std-condition-variable" class="headerlink" title="std::condition_variable"></a>std::condition_variable</h3><p>C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到别唤醒，现在在从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;           // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;             // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;              // std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt; // std::condition_variable</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_id</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!ready) cv.wait(lck);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cv.notify_all();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// spawn 10 threads:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(print_id, i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 threads ready to race...\n&quot;</span>;</span><br><span class="line">go();                       <span class="comment">// go!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，在14行中调用cv.wait(lck)的时候，线程将进入休眠，在调用33行的go函数之前，10个线程都处于休眠状态，当22行的cv.notify_all()运行后，14行的休眠将结束，继续往下运行，最终输出如上结果。</p>
<h2 id="智能指针内存管理"><a href="#智能指针内存管理" class="headerlink" title="智能指针内存管理"></a>智能指针内存管理</h2><p>在内存管理方面，C++11的std::auto_ptr基础上，移植了boost库中的智能指针的部分实现，如std::shared_ptr、std::weak_ptr等，当然，像boost::thread一样，C++11也修复了boost::make_shared中构造参数的限制问题。</p>
<p>什么是智能指针？网上已经有很多解释，个人觉得“智能指针”这个名词似乎起得过于“霸气”，很多初学者看到这个名词就觉得似乎很难。</p>
<p>简单地说，智能指针只是用对象去管理一个资源指针，同时用一个计数器计算当前指针引用对象的个数，当管理指针的对象增加或减少时，计数器也相应加1或减1，当最后一个指针管理对象销毁时，计数器为1，此时在销毁指针管理对象的同时，也把指针管理对象所管理的指针进行delete操作。</p>
<h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p>std::shared_ptr包装了new操作符动态分配的内存，可以自由拷贝复制，基本上是使用最多的一个智能指针类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Test()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Test&gt; p1 = <span class="built_in">std</span>::make_shared&lt;Test&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1 ref:&quot;</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Test&gt; p2 = p1;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2 ref:&quot;</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3 ref:&quot;</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test()</span><br><span class="line">1 ref:1</span><br><span class="line">2 ref:2</span><br><span class="line">3 ref:1</span><br><span class="line">~Test()</span><br></pre></td></tr></table></figure>

<p>上面代码需要了解的是：</p>
<ol>
<li>std::make_shared封装了new方法，boost::make_shared之前的原则是既然释放资源delete由智能指针负责，那么应该把new封装起来，否则会让人觉得自己调用了new，但没有调用delete，似乎与谁申请，谁释放的原则不符。C++也沿用了这一做法。</li>
<li>随着引用对象的增加std::shared_ptr<Test> p2 = p1，指针的引用计数有1变为2，当p2退出作用域后，p1的引用计数变回1，当main函数退出后，p1离开main函数的作用域，此时p1被销毁，当p1销毁时，检测到引用计数已经为1，就会在p1的析构函数中调用delete之前std::make_shared创建的指针。</li>
</ol>
<h3 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h3><p>std::weak_ptr网上很多人说其实是为了解决std::shared_ptr在相互引用的情况下出现的问题而存在的，C++官网对这个只能指针的解释也不多，那就先甭管那么多了，让我们暂时完全接受这个观点。</p>
<p>std::weak_ptr有什么特点呢？与std::shared_ptr最大的差别是在赋值时，不会引起智能指针计数增加。<br>我们下面将继续如下两点：</p>
<ol>
<li>std::shared_ptr相互引用会有什么后果；</li>
<li>std::weak_ptr如何解决第一点的问题。</li>
</ol>
<p><strong>A、std::shared_ptr相互引用的问题</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TestA()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;TestA()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReferTestB</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestB&gt; test_ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_TestB_Ptr = test_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ~TestA()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~TestA()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestB&gt; m_TestB_Ptr; <span class="comment">//TestB的智能指针</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TestB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;TestB()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReferTestB</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestA&gt; test_ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_TestA_Ptr = test_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~TestB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~TestB()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestA&gt; m_TestA_Ptr; <span class="comment">//TestA的智能指针</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestA&gt; ptr_a = <span class="built_in">std</span>::make_shared&lt;TestA&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestB&gt; ptr_b = <span class="built_in">std</span>::make_shared&lt;TestB&gt;();</span><br><span class="line">    ptr_a-&gt;ReferTestB(ptr_b);</span><br><span class="line">    ptr_b-&gt;ReferTestB(ptr_a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TestA()</span><br><span class="line">TestB()</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们创建了一个TestA和一个TestB的对象，但在整个main函数都运行完后，都没看到两个对象被析构，这是什么问题呢？<br>原来，智能指针ptr_a中引用了ptr_b，同样ptr_b中也引用了ptr_a，在main函数退出前，ptr_a和ptr_b的引用计数均为2，退出main函数后，引用计数均变为1，也就是相互引用。</p>
<p>这等效于说：</p>
<blockquote>
<ol>
<li>ptr_a对ptr_b说，哎，我说ptr_b，我现在的条件是，你先释放我，我才能释放你，这是天生的，造物者决定的，改不了。</li>
<li>ptr_b也对ptr_a说，我的条件也是一样，你先释放我，我才能释放你，怎么办？</li>
</ol>
</blockquote>
<p>是吧，大家都没错，相互引用导致的问题就是释放条件的冲突，最终也可能导致内存泄漏。</p>
<p><strong>B、std::weak_ptr如何解决相互引用的问题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TestA()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;TestA()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReferTestB</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestB&gt; test_ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_TestB_Ptr = test_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~TestA::TestWork()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~TestA()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~TestA()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;TestB&gt; m_TestB_Ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TestB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;TestB()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReferTestB</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestA&gt; test_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_TestA_Ptr = test_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~TestB::TestWork()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~TestB()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestA&gt; tmp = m_TestA_Ptr.lock();</span><br><span class="line">    tmp-&gt;TestWork();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2 ref a:&quot;</span> &lt;&lt; tmp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~TestB()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;TestA&gt; m_TestA_Ptr;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestA&gt; ptr_a = <span class="built_in">std</span>::make_shared&lt;TestA&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TestB&gt; ptr_b = <span class="built_in">std</span>::make_shared&lt;TestB&gt;();</span><br><span class="line">    ptr_a-&gt;ReferTestB(ptr_b);</span><br><span class="line">    ptr_b-&gt;ReferTestB(ptr_a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1 ref a:&quot;</span> &lt;&lt; ptr_a.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1 ref b:&quot;</span> &lt;&lt; ptr_a.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TestA()</span><br><span class="line">TestB()</span><br><span class="line">1 ref a:1</span><br><span class="line">1 ref b:1</span><br><span class="line">~TestA::TestWork()</span><br><span class="line">2 ref a:2</span><br><span class="line">~TestB()</span><br><span class="line">~TestA()</span><br></pre></td></tr></table></figure>

<p>由运行结果，可以看到：</p>
<ol>
<li>所有的对象最后都能正常释放，不会存在上一个例子中的内存没有释放的问题。</li>
<li>ptr_a和ptr_b在main函数中退出前，引用计数均为1，也就是说，在TestA和TestB中对std::weak_ptr的相互引用，不会导致计数的增加。在TestB析构函数中，调用std::shared_ptr<TestA> tmp = m_TestA_Ptr.lock()，把std::weak_ptr类型转换成std::shared_ptr类型，然后对TestA对象进行调用。</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="std-function、std-bind封装可执行对象"><a href="#std-function、std-bind封装可执行对象" class="headerlink" title="std::function、std::bind封装可执行对象"></a>std::function、std::bind封装可执行对象</h3><p>std::bind和std::function也是从boost中移植进来的C++新标准，这两个语法使得封装可执行对象变得简单而易用。此外，std::bind和std::function也可以结合我们一下所说的lambda表达式一起使用，使得可执行对象的写法更加“花俏”。</p>
<p>通过实例一步步了解std::function和std::bind的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Test.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.Add();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>上面代码中，我们实现了一个add函数和一个Test类，Test类里面也有一个函数Add。</li>
</ul>
<p>OK，我们现在来考虑一下这个问题，假如我们的需求是让Test里面的Add由外部实现，如main.cpp里面的add函数，有什么方法呢？<br>没错，我们可以用函数指针。</p>
<p>修改Test.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*FunType)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(FunType fun,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = fun(a, b);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改main.cpp的调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">....</span><br><span class="line">Test test;</span><br><span class="line">test.Add(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum:3</span><br></pre></td></tr></table></figure>

<p>到现在为止，完美了吗？</p>
<p>我们把问题升级，假如add实现是在另外一个类内部，如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    <span class="comment">//test.Add(add, 1, 2);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如add方法在TestAdd类内部，那你的Test类没辙了，因为Test里的Test函数只接受函数指针。你可能说，这个不是我的问题啊，我是接口的定义者，使用者应该遵循我的规则。但如果现在我是客户，我们谈一笔生意，就是我要购买使用你的Test类，前提是需要支持我传入函数指针，也能传入对象函数，你做不做这笔生意？</p>
<p>是的，你可以选择不做这笔生意。我们现在再假设你已经好几个月没吃肉了（别跟我说你是素食主义者），身边的苍蝇肉、蚊子肉啊都不被你吃光了，好不容易等到有机会吃肉，那有什么办法呢？<br>这个时候std::function和std::bind就帮上忙了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Test.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; fun, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = fun(a, b);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>Test类中std::function&lt;int(int,int)&gt;表示std::function封装的可执行对象返回值和两个参数均为int类型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;add&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;TestAdd::Add&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    test.Add(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    TestAdd testAdd;</span><br><span class="line">    test.Add(<span class="built_in">std</span>::bind(&amp;TestAdd::Add, testAdd, <span class="built_in">std</span>::placeholders::_1, <span class="built_in">std</span>::placeholders::_2), <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><p>std::bind第一个参数为对象函数指针，表示函数相对于类的首地址的偏移量；</p>
</li>
<li><p>testAdd为对象指针；</p>
</li>
<li><p>std::placeholders::_1和std::placeholders::_2为参数占位符，表示std::bind封装的可执行对象可以接受两个参数。</p>
</li>
</ul>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add</span><br><span class="line">sum:3</span><br><span class="line">TestAdd::Add</span><br><span class="line">sum:3</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><h4 id="知识背景：尾置返回类型"><a href="#知识背景：尾置返回类型" class="headerlink" title="知识背景：尾置返回类型"></a>知识背景：尾置返回类型</h4><p>C++11标准中，引入定义函数时的一种新的方法，使用<strong>尾置返回类型</strong>。这种形式对于返回类型比较复杂的情况很有效。</p>
<p>通常情况下，我们定义或声明一个函数时，是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>尾置返回类型的定义是这样的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto add(int a, int b) -&gt; int;</span><br></pre></td></tr></table></figure>

<p>当我们定义一个返回指向10个元素的int数组指针的函数时，按照正常形式是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func())[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>当使用尾置返回类型时，是这样的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto func() -&gt; int(*)[10];</span><br></pre></td></tr></table></figure>

<h4 id="lambda表达式-1"><a href="#lambda表达式-1" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>lambda采用尾置返回类型，它完整的const声明形式为: <code>[] (参数列表) -&gt; 返回值类型 &#123;函数体&#125;</code>, const是指在捕获列表内通过值捕获的参数在lambda内部是不可以改变的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt;<span class="keyword">bool</span> &#123; <span class="keyword">return</span> a &lt; b;&#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(<span class="built_in">array</span>.begin(), <span class="built_in">array</span>.end(), func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> func1 = [a] () &#123;++a;&#125;;             <span class="comment">// 编译错误， 变量a的类型在lambda体内为const的。</span></span><br><span class="line">    <span class="keyword">auto</span> func2 = [a] () <span class="keyword">mutable</span> &#123;++a;&#125;;     <span class="comment">// 没有问题</span></span><br><span class="line">    <span class="keyword">auto</span> func3 = [&amp;a] () &#123;++a;&#125;;            <span class="comment">// 没有问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数列表与返回值类型可以根据是否需要，进行省略掉, 规则如下：</p>
<ul>
<li><p>当定义的lambda表达式的参数为空时，参数可以省略掉，省略后的表达式形式为： <code>[] -&gt; 返回值类型 &#123;函数体 &#125;</code></p>
</li>
<li><p>当定义的lambda表达式的函数体仅有一条 <code>return ****</code> 的语句时，返回值类型也可以省略，编译器会根据返回值的类型自动推断。 但是如果函数体是多条语句而你省略了返回值类型，编译器认为返回类型是void. 例如下面的lambda表达式的返回值类型默认为void, 一看就不对啊，所以此时你别省略返回值类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> Addfunc = [] (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">int</span> c = a + b; <span class="keyword">return</span> c;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>捕获列表与函数体任何时候都不可以省略。</p>
</li>
</ul>
<p><strong>捕获列表</strong></p>
<p>捕获列表只需要捕获lambda所在作用域内常规的局部变量，对于非局部变量以及局部的静态变量不需要捕获，可以直接使用。 例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g_value = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> value2 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [value1]() &#123;<span class="built_in">cout</span> &lt;&lt; g_value &lt;&lt; value1 &lt;&lt; value2; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>值捕获</strong></p>
<p><strong>方式一:</strong> 使用 <code>[=]</code> 隐式捕获lambda内所有使用到的变量的值。<br><strong>方式二:</strong> 使用 <code>[val1, val2, val3, ...]</code> 显示捕获lambda内使用到的变量的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> value2 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> value3 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> func1 = [=] () -&gt; <span class="keyword">int</span> &#123;<span class="keyword">return</span> value1 + value2 + value3;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> func2 = [value1, value2, value3] () &#123;value1 + value2 + value3;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用捕获</strong></p>
<p><strong>方式一:</strong> 使用 <code>[&amp;]</code> 隐式捕获lambda内所有使用到的变量的值。<br><strong>方式二:</strong> 使用 <code>[&amp;val1, &amp;val2, &amp;val3, ...]</code> 显示捕获lambda内使用到的变量的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> value2 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> value3 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> func1 = [&amp;] () -&gt; <span class="keyword">int</span> &#123;<span class="keyword">return</span> value1 + value2 + value3;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> func2 = [&amp;value1, &amp;value2, &amp;value3] () &#123;<span class="keyword">return</span> value1 + value2 + value3;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>混合捕获</strong></p>
<p><strong>方式一:</strong> 使用 <code>[val1, &amp;val2, val3, ...]</code> 随意的组合值捕获和引用捕获来获取lambda内使用到的变量的值。<br><strong>方式二:</strong> 使用 <code>[=, &amp;val1, &amp;val2, ...]</code> 表示除了手动指出来的变量通过引用捕获之外，其它的变量都是通过值进行捕获。<br><strong>方式三:</strong> 使用 <code>[&amp;, val1, val2, ...]</code> 表示除了手动指出来的变量通过值捕获之外，其它的变量都是通过引用进行捕获。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> value2 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> value3 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> func1 = [value1, &amp;value2, value3] () &#123;<span class="keyword">return</span> value1 + value2 + value3;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> func2 = [=, &amp;value2] () &#123;<span class="keyword">return</span> value1 + value2 + value3;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> func3 = [&amp;, value3] () &#123;<span class="keyword">return</span> value1 + value2 + value3;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项:</strong></p>
<blockquote>
<ol>
<li>当lambda表达式定义在类内的成员函数时，如果在lambda表达式内部要访问类的成员函数或成员变量(无论public/protected/private)时，要么显示捕获this指针，要么通过[=]或[&amp;]进行隐式捕获。</li>
<li>使用引用捕获时，特别注意这些参数实体的生存期,保证调用lambda时这些实体是有意义的，避免悬垂引用的产生。</li>
</ol>
</blockquote>
<p><strong>使用mutable关键字修饰的lambda</strong></p>
<p>默认的lamba的声明方式是const声明，通过值获取的参数在lambda内是无法修改的，如果要改变该值，在参数列表后面加上mutable关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> func1 = [a] () &#123;++a;&#125;;             <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="keyword">auto</span> func2 = [a] () <span class="keyword">mutable</span> &#123;++a;&#125;;     <span class="comment">// 没有问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lambda表达式本身是纯右值表达式(你不可能对它的结果取地址的), 它的类型独有的无名非联合非聚合类类型，被称为闭包类型(closure type), 它可以有以下两个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ret-<span class="function">type <span class="title">operator</span><span class="params">()</span> <span class="params">(参数列表)</span> <span class="keyword">const</span> </span>&#123;函数体&#125;     <span class="comment">// 未使用关键字mutable时，默认情况</span></span><br><span class="line">ret-<span class="function">type <span class="title">operator</span><span class="params">()</span> <span class="params">(参数列表)</span> </span>&#123;函数体&#125;           <span class="comment">// 使用了mutable 关键字时</span></span><br></pre></td></tr></table></figure>

<p><strong>友情提示:</strong></p>
<blockquote>
<p>mutable 关键字只对值捕获参数有影响，对引用捕获的参数无影响。原因是：引用参数能否修改为参数本身是否为const类型决定。即使一个类的成员函数有 const 声明(该const就是修改this指针的)，照样可以通过该成员函数修改一个引用类型的成员变量,例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span>&amp; value) : a(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Increase</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;++a;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>&amp; a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
</search>
